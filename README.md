# nats-connector
A pluggable service to bridge NATS and other technologies

## Work in Progress
Code here is prototype/experimental code, incomplete, and not ready for public consumption.  Feel free to browse, but using this right now would not be a good idea.

## Summary

The NATS connector is provided to facilitate the bridging of NATS and other technologies with a general, easy to use, plug-in framework.  
General application tasks and NATS connectivity are taken care of, allowing a developer to focus on the technology rather than application development.

The java platform was chosen to provide allow the most coverage as possible - most other technologies have a Java API.

Some plug-ins will be provided and maintained by Apcera.

### Source code (this repository)
To download the source code:
```
git clone git@github.com:nats-io/nats-connector.git .
```

To build the library, use [maven](https://maven.apache.org/). From the root directory of the project:

```
mvn clean package -DskipTests
```


## NATS connector source package structure

* io.nats.connector - Connector application and data flow management
* io.nats.connector.plugin - Interfaces, Classes, and Enums used by plugin developers.
* io.nats.connector.plugins - Out of the box plugins, developed by Apcera.

## Configuration
On the NATS side, it is very simple, simply set java properties NATS will use.  (See jnats)

There is only one NATS connector parameter, which specifies the plugin class used.

com.io.nats.connector.plugin=<classname of the plugin>

For example, to use the NATS Redis plugin, specify:
```
com.io.nats.connector.plugin=io.nats.connector.plugins.redis.RedisPubSubPlugin
```

## Apcera Supported Plugins

### Redis plugin

The redis plugin is:
```
com.io.nats.connector.plugins.redis.RedisPubSubPlugin
```

#### Configuration

The NATS Redis plugin is configured by specifying a url that returns JSON file as a system property.  In this example, 
the url specifies a local file.  It can be any location that meets the URI standard.

```
-Dnats.io.connector.plugins.redispubsub.configurl="file:///Users/colinsullivan/redis_nats_connector.json"
```
in code:
```
System.setProperty(RedisPubSubPlugin.CONFIG_URL, "file:///Users/colinsullivan/redis_nats_connector.json");
```

The Redis Pub/Sub plugin configuration file read at the URI must have the following format:

```
{
    "host" : "localhost",
    "port" : 6379,
    "timeout" : 2000,
    "nats_to_redis_map" : [
        {
            "subject" : "Export.Redis",
            "channel" : "Import_NATS"
        }
    ],
    "redis_to_nats_map" : [
        {
            "channel" : "Export_NATS",
            "subject" : "Import.Redis",
        }
    ]
}

```

* Host is the redis cluster host.
* Port is the redis port.
* Timeout is the Redis timeout.

The nats_to_redis_map array is a list of NATS subjects mapped to Redis channels.  NATS wildcarding is supported.  
So, in this case, any messages published to Export.Redis in the NATS cluster will be received, and published onto
the Redis Channel "Import_NATS".

From the other direction, any message published from redis on the Export_NATS channel, will be published into
the NATS cluster on the Import.Redis subject.  At least one map needs to be defined.

Wildcarding and pattern matching is supported.

Circular message routes generated by overlapping maps should be avoided.

Basic circular route detection is performed, but this could be easily achieved through NATS wildcarding or
Redis patterns. While a circular route is considered a serious misconfiguration, it does provide a nice stress test 
for Redis.


## Plugin Development

Plugin development is straightforward, simply implement the NATSConnectorPlugin interface.


```java
/**
 * This interface that must be implemented for a NATS Connector plugin.
 *
 * The order of calls are:
 *
 * OnStartup
 * OnNatsIntialized
 *
 * ...
 * OnNatsMessage, OnNATSEvent
 * ...
 * OnShutdown
 */
public interface NATSConnectorPlugin {

    /**
     * Invoked when the connector is started up, before a connection
     * to the NATS cluster is made.  The NATS connection factory is
     * valid at this time, providing an opportunity to alter
     * NATS connection parameters based on other plugin variables.
     *
     * @param logger - logger for the NATS connector process.
     * @param factory - the NATS connection factory.
     * @return - true if the connector should continue, false otherwise.
     */
    public boolean OnStartup(Logger logger, ConnectionFactory factory);

    /**
     * Invoked after startup, when the NATS plug-in has connectivity to the
     * NATS cluster, and is ready to start sending and
     * and receiving messages.  This is the place to create NATS subscriptions.
     *
     * @param connector interface to the NATS connector
     *
     * @return true if the plugin can continue.
     */
    public boolean OnNatsInitialized(NATSConnector connector);

    /**
     * Invoked anytime a NATS message is received to be processed.
     * @param msg - NATS message received.
     */
    public void OnNATSMessage(io.nats.client.Message msg);

    /**
     * Invoked anytime a NATS event occurs around a connection
     * or error, alerting the plugin to take appropriate action.
     *
     * For example, when NATS is reconnecting, buffer or pause incoming
     * data to be sent to NATS.
     *
     * @param event the type of event
     * @param message a string describing the event
     */
    public void OnNATSEvent(NATSEvent event, String message);


    /**
     * Invoked when the Plugin is shutting down.  This is typically where
     * plugin resources are cleaned up.
     */
    public void OnShutdown();
}
```

Most plugins will require certain NATS functionality.  For convenience a NATS Connector object is passed to the plugin after
NATS has been initialized.  If more NATS functionality is required, the Connection and Connection factory is available.
```java
public interface NATSConnector {

    /**
     * In case of a critical failure or security issue, this allows the plugin
     * to request a shutdown of the connector.
     */
    public void shutdown();

    /***
     * Publishes a message into the NATS cluster.
     *
     * @param message - the message to publish.
     */
    public void publish(io.nats.client.Message message);

    /***
     * Flushes any pending NATS data.
     *
     * @throws  Exception
     */
    public void flush() throws Exception;

    /***
     * Adds interest in a NATS subject.
     * @throws Exception
     */
    public void subscribe(String subject) throws Exception;

    /***
     * Adds interest in a NATS subject, with a custom handler.
     * @throws Exception
     */
    public void subscribe(String subject, MessageHandler handler) throws Exception;

    /***
     * Adds interest in a NATS subject with a queue group.
     * @throws Exception
     */
    public void subscribe(String subject, String queue) throws Exception;

    /***
     * Adds interest in a NATS subject with a queue group, with a custom handler.
     * @throws Exception
     */
    public void subscribe(String subject, String queue, MessageHandler handler) throws Exception;

    /***
     * Removes interest in a NATS subject
     * @param subject
     */
    public void unsubscribe(String subject);

    /***
     * Advanced API to get the NATS connection
     *
     * @return The connection to the NATS cluster.
     */
    public Connection getConnection();

    /***
     * Advanced API to get the Connection Factory
     *
     * @return The NATS connector ConnectionFactory
     */
    public ConnectionFactory getConnectionFactory();


}
```


## TODO

- [ ] Complete Redis Plugin, reconnect, additional parameters
- [ ] Travis CI
- [ ] Kafka Plugin
- [ ] Maven Central
- [ ] Containerize